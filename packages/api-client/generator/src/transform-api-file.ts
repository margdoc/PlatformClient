import { promises as fsPromises } from "fs";
import {
  Project, VariableDeclarationKind
} from "ts-morph";

import {
  createClassFromSource,
  createInterfaceFromSource,
  extractArrowFunctionFromClassProperty,
  fixFileImports,
  ContextOptions,
} from "../utils/ast-utils";

import { capitalizeFirstLetter } from "../utils/text";

/**
 * This function takes source code input and outputs the parameter type of the Observable returned by the function.
 * So for input:
 * {identifier} = ({some_parameters}): Observable<{type}> => { {code} }
 *
 * The output will be: {type}.
 * If the code is not matching the format described there, "any" string is returned.
 *
 * @param code - input code with arrow function to be parsed
 */
function extractReturnedObservableTypeFromArrowFunctionDefinition(code: string) {
  const matchReturnedObservableRegex = new RegExp(/\w\s*=\s*\([^)]*\):\s*Observable<([^\s]+)>\s*=>\s*{/ig);
  const matches = matchReturnedObservableRegex.exec(code);
  if (matches && matches[1]) {
    return matches[1];
  }
  return "any";
}

/**
 * Entrypoint to the transformer. Transforms the api file genrated by openapi-genrator.
 *
 * @param path - path to the DefaultApi.ts file generated by openapi-generator
 */
export async function transformDefaultApiFile(path: string, prefixHttpRequest: string) {

  const fileHandle = await fsPromises.open(path, "r");
  const inputContent = await fileHandle.readFile();
  await fileHandle.close();

  const contextOptions: ContextOptions = {
    baseFileContents: inputContent.toString(),
    baseFileName: path,
  };

  // initialize
  const project = new Project({});

  // add source files
  project.addExistingSourceFiles(path);

  const inputFile = project.createSourceFile(path, inputContent.toString(), { overwrite: true });

  /*
   * Add basic imports
   */
  inputFile.addImportDeclaration({
    defaultImport: "{ Action, AnyAction }",
    moduleSpecifier: "redux"
  });

  inputFile.addImportDeclaration({
    //groupBy, switchMap removed not to cause warnings; might be useful in the future
    //defaultImport: "{ groupBy, map, mergeMap, switchMap }",
    defaultImport: "{ map, mergeMap }",
    moduleSpecifier: "rxjs/operators"
  });

  inputFile.addImportDeclaration({
    defaultImport: "{ ofType, Effect, Epic }",
    moduleSpecifier: "utils/Loop"
  });

  /*
   * Add Request<T, P, R, A> class definition.
   */
  const requestClass = inputFile.addClass(await createClassFromSource(contextOptions, "Request", `
      export class Request<T, P, R, A extends Action> implements Effect<A> {
        readonly type = "${prefixHttpRequest}";

        constructor(
          readonly operationType: T,
          readonly payload: P,
          readonly onResponse: (payload: R) => A,
          readonly tracker?: string
        ) {}

        map<B extends Action>(mapper: (from: A) => B): Request<T, P, R, B> {
          return new Request(this.operationType, this.payload, p => mapper(this.onResponse(p)));
        }
      }
  `));

  /*
   * Add WebAppClient class definition
   */
  const clientClass = inputFile.addClass(await createClassFromSource(contextOptions, "WebAppClient", `
      export class WebAppClient {};
  `));

  /*
   * Get the class (DefaultApi) generated by OpenApi genreator
   */
  const apiClass = inputFile.getClassOrThrow("DefaultApi");
  apiClass.setIsExported(false);
  const apiClassMethods = apiClass.getMembers();

  /*
   * Capture metadata from parsing fields of DefaultApi class
   */
  const generatedOeprationClassMetas: Map<string, {
    operationName: string;
    payloadType: string | null;
    responseType: string;
  }> = new Map();

  /*
   * Iterate over methods inside DefaultApi class and generate utilities for them
   */
  for (const member of apiClassMethods) {
    const method = await extractArrowFunctionFromClassProperty(contextOptions, member);

    if (method !== undefined) {

      const params = method.getParameters();

      if (params.length > 0) {
        const requestParamsType = params[0].getType();
        const requestParamsName = params[0].getName();

        const operationClassName = capitalizeFirstLetter(method.getName() || "");
        const responseType = extractReturnedObservableTypeFromArrowFunctionDefinition(member.getText());
        const payloadType = requestParamsType.getText();

        generatedOeprationClassMetas.set(operationClassName, {
          operationName: method.getName() || "",
          payloadType,
          responseType,
        });

        /*
         * Generate class extending Request specific for that operation
         */
        const operationClass = inputFile.addInterface(await createInterfaceFromSource(contextOptions, operationClassName, `
            export interface ${operationClassName}<A extends Action> extends Request<"${prefixHttpRequest}/${operationClassName}", ${requestParamsType.getText()}, ${responseType}, A> {
                operationType: "${prefixHttpRequest}/${operationClassName}";
            };
        `));

        /*
         * Add operation to the utility class
         */
        const clientMethod = clientClass.addMethod({
          isStatic: true,
          name: method.getName() || "",
          returnType: `${operationClassName}<A>`
        });

        clientMethod.insertTypeParameter(0, {
          name: "A",
          constraint: "Action",
        });
        clientMethod.insertParameter(0, params[0].getStructure());
        clientMethod.insertParameter(1, {
          name: "onResponse",
          type: `(response: ${responseType}) => A`,
        });

        clientMethod.setBodyText(`
          return new Request("${prefixHttpRequest}/${operationClassName}", ${requestParamsName}, onResponse);
        `);
      } else {
        const operationClassName = capitalizeFirstLetter(method.getName() || "");
        const responseType = extractReturnedObservableTypeFromArrowFunctionDefinition(member.getText());

        generatedOeprationClassMetas.set(operationClassName, {
          operationName: method.getName() || "",
          payloadType: null,
          responseType,
        });

        /*
         * Generate class extending Request specific for that operation
         */
        const operationClass = inputFile.addInterface(await createInterfaceFromSource(contextOptions, operationClassName, `
            export interface ${operationClassName}<A extends Action> extends Request<"${prefixHttpRequest}/${operationClassName}", undefined, ${responseType}, A> {
                operationType: "${prefixHttpRequest}/${operationClassName}";
            };
        `));

        /*
         * Add operation to the utility class
         */
        const clientMethod = clientClass.addMethod({
          isStatic: true,
          name: method.getName() || "",
          returnType: `${operationClassName}<A>`
        });

        clientMethod.insertTypeParameter(0, {
          name: "A",
          constraint: "Action",
        });
        clientMethod.insertParameter(0, {
          name: "onResponse",
          type: `(response: ${responseType}) => A`,
        });

        clientMethod.setBodyText(`
          return new Request("${prefixHttpRequest}/${operationClassName}", undefined, onResponse);
        `);
      }
    }

  }

  /*
   * Generate union type for all requests supported by the client
   */
  const OperationRequestTypeAliast = inputFile.addTypeAlias({
    name: "RequestAPI<A extends Action>",
    type: [...generatedOeprationClassMetas.entries()].map(([opClassName, _]) => `${opClassName}<A>`).join(" | "),
  });

  /*
   * Generate source code for epic handling the client requests
   */
  const epicSwitchText = [...generatedOeprationClassMetas.entries()].map(([opClassName, { operationName, payloadType }]) => {
    if (payloadType === null) {
      return `case "${prefixHttpRequest}/${opClassName}": return apiClient.${operationName}().pipe(map((response) => action.onResponse(response)));`;
    }
    return `case "${prefixHttpRequest}/${opClassName}": return apiClient.${operationName}(action.payload).pipe(map((response) => action.onResponse(response)));`;
  }).join("\n");

  const defaultTrackerConst = inputFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    declarations: [{
      name: "defaultTracker",
      initializer: `Symbol("defaultTracker")`,
    }]
  });
  defaultTrackerConst.setIsExported(true);

  /*
   * Generate constant global variable capturing client instance
   */
  const apiClientInstance = inputFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    declarations: [{
      name: "apiClient",
      type: "DefaultApi",
      initializer: `new DefaultApi()`,
    }]
  });

  /*
   * Generate handler function
   */
  const handlerFunc = inputFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    declarations: [{
      name: "__unsafeHandleApiAction",
      initializer: `(action: RequestAPI<AnyAction>) => {
    switch (action.operationType) {
        ${epicSwitchText}
     }
}`,
    }]
  });
  // Do not export handler
  handlerFunc.setIsExported(false);

  /*
   * Generate handler function
   */
  const handlerFuncWrapper = inputFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    declarations: [{
      name: "__unsafeCallApi",
      initializer: `(action: RequestAPI<AnyAction>, callback: (data: any) => void) => {
    const u = __unsafeHandleApiAction(action);
    u.subscribe(a => {
        callback(a);
    });
};`,
    }]
  });
  // Export handler unsafe wrapper
  handlerFuncWrapper.setIsExported(true);

  /*
   * Generate epic for handling the requests
   */
  const epicExport = inputFile.addVariableStatement({
    declarationKind: VariableDeclarationKind.Const,
    declarations: [{
      name: "epic",
      type: "Epic<Action, AnyAction>",
      initializer: `(effect$) =>
effect$.pipe(
  ofType<RequestAPI<Action>>("${prefixHttpRequest}"),
  mergeMap(__unsafeHandleApiAction)
)`,
    }]
  });
  // Export the epis
  epicExport.setIsExported(true);

  /*
   * Save the files
   */
  inputFile.formatText({
    placeOpenBraceOnNewLineForFunctions: true,
  });
  await project.save();

  await fixFileImports(path);

}